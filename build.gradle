
import groovy.json.JsonSlurper

buildscript {
    dependencyLocking {
        lockAllConfigurations()
    }

    repositories {
		gradlePluginPortal()
		if (springBootVersion.endsWith('SNAPSHOT') || springCloudVersion.endsWith('SNAPSHOT')) {
			maven { url 'https://repo.spring.io/snapshot' }
		}
	}
    dependencies {
        classpath 'io.spring.nohttp:nohttp-gradle:0.0.11'
        classpath "org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}"
    }
    configurations.classpath.resolutionStrategy.cacheDynamicVersionsFor 0, 'minutes'
}

def getVersionFromPackageJson() {
    def packageJsonFile = file('package.json')
    if (packageJsonFile.exists()) {
        def packageJson = new JsonSlurper().parseText(packageJsonFile.text)
        return packageJson.version
    } else {
        throw new GradleException("package.json file not found")
    }
}


apply plugin: 'org.springframework.boot'
description = 'Cross training Infrastructure'

allprojects {
    group = 'cloud.crosstraining.infra'
    version =  getVersionFromPackageJson()
    afterEvaluate { project -> println "I'm configuring $project.name with version $project.version" }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'io.spring.nohttp'
    apply plugin: 'maven-publish'
    apply plugin: 'org.springframework.boot'

    java {
        registerFeature('optional') {
            usingSourceSet(sourceSets.main)
        }

        toolchain {
            languageVersion = JavaLanguageVersion.of(17)
        }
    }

    bootJar {
        archiveFileName = "${projectDir.absolutePath}/app.jar"
    }

    bootRun {
        doFirst {
            def envFileName = System.getenv("ENV_FILE") ?: '.env'
            def envFile = file(envFileName)
            if (envFile.exists()) {
                envFile.eachLine { line ->
                    def (key, value) = line.split('=')
                    environment key, value
                }
            }
        }
    }

    repositories {
        mavenCentral()
        maven { url 'https://repo.spring.io/milestone' }
        if (springBootVersion.endsWith('SNAPSHOT') || springCloudVersion.endsWith('SNAPSHOT')) {
            maven { url 'https://repo.spring.io/snapshot' }
            maven { url 'https://repo.spring.io/milestone' }
        }
    }

    dependencies {        
        implementation platform("org.springframework.boot:spring-boot-dependencies:${springBootVersion}")
        implementation platform("org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}")
        implementation 'org.springframework.boot:spring-boot-starter-web'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'       
        implementation 'io.micrometer:micrometer-registry-prometheus'
        implementation 'io.micrometer:micrometer-tracing-bridge-brave'
        implementation 'io.zipkin.reporter2:zipkin-reporter-brave'        
        testImplementation 'org.springframework.boot:spring-boot-starter-test'
        // JSR-305 only used for non-required meta-annotations
        optionalApi 'com.google.code.findbugs:jsr305:latest.release'
    }

    tasks {
        compileJava {
            options.encoding = 'UTF-8'
            options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'

            doLast {
                task -> logger.info("Compiling with " + task.javaCompiler.get().executablePath)
            }
        }
        compileTestJava {
            options.encoding = 'UTF-8'
            options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
        }

        javadoc {
            enabled = false
        }

        // Disable Checkstyle tasks
        withType(Checkstyle) {
            enabled = false
        }
    }

    normalization {
        runtimeClasspath {
            metaInf {
                [
                        'Build-Date',
                        'Build-Date-UTC',
                        'Built-By',
                        'Built-OS',
                        'Build-Host',
                        'Build-Job',
                        'Build-Number',
                        'Build-Id',
                        'Change',
                        'Full-Change',
                        'Branch',
                        'Module-Origin',
                        'Created-By',
                        'Build-Java-Version'
                ].each {
                    ignoreAttribute it
                    ignoreProperty it
                }
            }
        }
    }

    //noinspection GroovyAssignabilityCheck
    test {
        // set heap size for the test JVM(s)
        maxHeapSize = "1500m"

        useJUnitPlatform()

        develocity.testRetry {
            maxFailures = 5
            maxRetries = 3
        }
    }

    plugins.withId('org.springframework.boot') {
        publishing {
            publications {
                bootJava(MavenPublication) {
                    artifact tasks.named("bootJar")
                }
            }
        }
    }

    plugins.withId('org.graalvm.buildtools.native') {
        tasks.withType(io.spring.javaformat.gradle.tasks.CheckFormat) {
            if (it.name in [ 'checkFormatAot', 'checkFormatAotTest' ]) {
                exclude '*'
            }
        }

        plugins.withId('org.springframework.boot') {
            checkstyle {
                checkstyleAot.enabled = false
                checkstyleAotTest.enabled = false
            }
        }
    }

    project.tasks.withType(Test) { Test testTask ->
        testTask.testLogging.exceptionFormat = 'full'
    }

    nohttp {
        source.exclude '**/docker/**/*.yml', '**/docker-compose.yml'
    }

    dependencyLocking {
        lockAllConfigurations()
    }

    tasks.register('resolveAndLockAll') {
        description = 'Resolves dependencies of all configurations and writes them into the lock file.'
        outputs.upToDateWhen { false }
        doFirst {
            assert gradle.startParameter.writeDependencyLocks || gradle.startParameter.lockedDependenciesToUpdate: 'Execute resolveAndLockAll --write-locks or --update-locks <dependencies>'
        }
        doLast {
            project.configurations.findAll { it.canBeResolved }*.resolve()
        }
    }

    tasks.register('downloadDependencies') {
        outputs.upToDateWhen { false }
        doLast {
            project.configurations.findAll { it.canBeResolved }*.files
        }
    }      
}

task deleteLockFiles(type: Delete) {
    delete fileTree(dir: '.', include: '**/gradle.lockfile')
}

wrapper {
    gradleVersion = '8.0.2'
}

defaultTasks 'build'
